// ============================================
// SESMine Platform - Enhanced JavaScript
// Smart Engineering Solutions for Mining
// Version: 2.0 - Professional Edition
// ============================================

'use strict';

// ==================== CONFIGURATION ====================
const CONFIG = {
  apiEndpoint: '/api',
  emailJSUserID: 'YOUR_EMAILJS_USER_ID',
  emailJSServiceID: 'YOUR_SERVICE_ID',
  animationDuration: 300,
  loadingDelay: 3500,
  notificationDuration: 5000,
  debounceDelay: 300,
  version: '2.0.0'
};

// ==================== STATE MANAGEMENT ====================
const AppState = {
  isLoading: false,
  currentUser: null,
  notifications: [],
  modals: {},
  theme: 'light',
  
  setState(key, value) {
    this[key] = value;
    this.emit('stateChange', { key, value });
  },
  
  getState(key) {
    return this[key];
  },
  
  listeners: {},
  
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  },
  
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(callback => callback(data));
    }
  }
};

// ==================== UTILITY FUNCTIONS ====================
const Utils = {
  // Debounce function
  debounce(func, wait = CONFIG.debounceDelay) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },
  
  // Throttle function
  throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  },
  
  // Format currency
  formatCurrency(amount, currency = 'USD') {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency
    }).format(amount);
  },
  
  // Format date
  formatDate(date, format = 'long') {
    return new Intl.DateTimeFormat('en-US', {
      dateStyle: format
    }).format(new Date(date));
  },
  
  // Generate unique ID
  generateID() {
    return `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  },
  
  // Validate email
  validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  },
  
  // Validate phone
  validatePhone(phone) {
    const regex = /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/;
    return regex.test(phone);
  },
  
  // Deep clone object
  deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  
  // Get query params
  getQueryParams() {
    const params = {};
    const searchParams = new URLSearchParams(window.location.search);
    for (const [key, value] of searchParams) {
      params[key] = value;
    }
    return params;
  },
  
  // Set query param
  setQueryParam(key, value) {
    const url = new URL(window.location);
    url.searchParams.set(key, value);
    window.history.pushState({}, '', url);
  },
  
  // Local storage with expiry
  setLocalStorage(key, value, expiryDays = 30) {
    const item = {
      value: value,
      expiry: Date.now() + (expiryDays * 24 * 60 * 60 * 1000)
    };
    localStorage.setItem(key, JSON.stringify(item));
  },
  
  getLocalStorage(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;
    
    const item = JSON.parse(itemStr);
    if (Date.now() > item.expiry) {
      localStorage.removeItem(key);
      return null;
    }
    return item.value;
  },
  
  // Scroll to element
  scrollToElement(selector, offset = 0) {
    const element = document.querySelector(selector);
    if (element) {
      const top = element.getBoundingClientRect().top + window.pageYOffset - offset;
      window.scrollTo({
        top: top,
        behavior: 'smooth'
      });
    }
  },
  
  // Copy to clipboard
  async copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (err) {
      console.error('Failed to copy:', err);
      return false;
    }
  }
};

// ==================== LOADING SYSTEM ====================
const LoadingManager = {
  overlay: null,
  messages: [
    'Initializing SESMine Platform...',
    'Loading Mining Intelligence Systems...',
    'Connecting Professional Hubs...',
    'Preparing Analytics Engine...',
    'Establishing Secure Connections...',
    'Platform Ready for Mining Excellence'
  ],
  
  init() {
    this.overlay = document.getElementById('loadingOverlay');
    if (!this.overlay) {
      this.createOverlay();
    }
  },
  
  createOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'loadingOverlay';
    overlay.className = 'loading-overlay';
    overlay.innerHTML = `
      <div class="loading-container">
        <div class="spinner"></div>
        <div class="loading-text">Initializing...</div>
      </div>
    `;
    document.body.appendChild(overlay);
    this.overlay = overlay;
  },
  
  show() {
    if (this.overlay) {
      this.overlay.classList.remove('hidden');
      this.animateMessages();
    }
  },
  
  hide() {
    if (this.overlay) {
      setTimeout(() => {
        this.overlay.classList.add('hidden');
      }, 500);
    }
  },
  
  animateMessages() {
    const textElement = this.overlay.querySelector('.loading-text');
    let index = 0;
    
    const interval = setInterval(() => {
      if (index < this.messages.length - 1) {
        index++;
        textElement.textContent = this.messages[index];
      } else {
        clearInterval(interval);
      }
    }, 600);
    
    setTimeout(() => {
      clearInterval(interval);
      this.hide();
    }, CONFIG.loadingDelay);
  }
};

// ==================== NOTIFICATION SYSTEM ====================
const NotificationManager = {
  container: null,
  
  init() {
    this.container = document.createElement('div');
    this.container.id = 'notificationContainer';
    this.container.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
    `;
    document.body.appendChild(this.container);
  },
  
  show(message, type = 'info', duration = CONFIG.notificationDuration) {
    const notification = this.createNotification(message, type);
    this.container.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.classList.add('show');
    }, 10);
    
    // Auto remove
    setTimeout(() => {
      this.remove(notification);
    }, duration);
    
    return notification;
  },
  
  createNotification(message, type) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    const icons = {
      success: 'fas fa-check-circle',
      error: 'fas fa-times-circle',
      warning: 'fas fa-exclamation-triangle',
      info: 'fas fa-info-circle'
    };
    
    notification.innerHTML = `
      <div class="notification-content">
        <i class="notification-icon ${icons[type]}"></i>
        <span class="notification-message">${message}</span>
        <button class="notification-close" onclick="this.parentElement.parentElement.remove()">
          <i class="fas fa-times"></i>
        </button>
      </div>
    `;
    
    return notification;
  },
  
  remove(notification) {
    notification.classList.remove('show');
    setTimeout(() => {
      notification.remove();
    }, 300);
  },
  
  success(message) {
    return this.show(message, 'success');
  },
  
  error(message) {
    return this.show(message, 'error');
  },
  
  warning(message) {
    return this.show(message, 'warning');
  },
  
  info(message) {
    return this.show(message, 'info');
  }
};

// ==================== MODAL MANAGER ====================
const ModalManager = {
  modals: {},
  
  init() {
    // Find all modals
    document.querySelectorAll('.modal').forEach(modal => {
      this.register(modal.id, modal);
    });
    
    // Close on backdrop click
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal')) {
        this.close(e.target.id);
      }
    });
    
    // Close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.closeAll();
      }
    });
  },
  
  register(id, element) {
    this.modals[id] = element;
  },
  
  open(id) {
    const modal = this.modals[id];
    if (modal) {
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
      AppState.emit('modalOpened', { id });
    }
  },
  
  close(id) {
    const modal = this.modals[id];
    if (modal) {
      modal.classList.remove('active');
      document.body.style.overflow = '';
      AppState.emit('modalClosed', { id });
    }
  },
  
  closeAll() {
    Object.keys(this.modals).forEach(id => this.close(id));
  },
  
  toggle(id) {
    const modal = this.modals[id];
    if (modal) {
      if (modal.classList.contains('active')) {
        this.close(id);
      } else {
        this.open(id);
      }
    }
  }
};

// ==================== FORM VALIDATION ====================
const FormValidator = {
  rules: {
    required: (value) => value.trim() !== '',
    email: (value) => Utils.validateEmail(value),
    phone: (value) => Utils.validatePhone(value),
    minLength: (value, length) => value.length >= length,
    maxLength: (value, length) => value.length <= length,
    pattern: (value, pattern) => new RegExp(pattern).test(value)
  },
  
  validate(form) {
    const errors = {};
    const formData = new FormData(form);
    
    form.querySelectorAll('[data-validate]').forEach(field => {
      const rules = field.dataset.validate.split('|');
      const value = formData.get(field.name);
      const fieldErrors = [];
      
      rules.forEach(rule => {
        const [ruleName, ruleValue] = rule.split(':');
        
        if (this.rules[ruleName]) {
          const isValid = ruleValue 
            ? this.rules[ruleName](value, ruleValue)
            : this.rules[ruleName](value);
          
          if (!isValid) {
            fieldErrors.push(this.getErrorMessage(ruleName, field.name, ruleValue));
          }
        }
      });
      
      if (fieldErrors.length > 0) {
        errors[field.name] = fieldErrors;
        this.showFieldError(field, fieldErrors[0]);
      } else {
        this.clearFieldError(field);
      }
    });
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors: errors
    };
  },
  
  getErrorMessage(rule, fieldName, value) {
    const messages = {
      required: `${fieldName} is required`,
      email: 'Please enter a valid email address',
      phone: 'Please enter a valid phone number',
      minLength: `Minimum length is ${value} characters`,
      maxLength: `Maximum length is ${value} characters`,
      pattern: 'Invalid format'
    };
    return messages[rule] || 'Invalid input';
  },
  
  showFieldError(field, message) {
    field.classList.add('error');
    let errorElement = field.parentElement.querySelector('.form-error');
    
    if (!errorElement) {
      errorElement = document.createElement('div');
      errorElement.className = 'form-error';
      field.parentElement.appendChild(errorElement);
    }
    
    errorElement.textContent = message;
  },
  
  clearFieldError(field) {
    field.classList.remove('error');
    const errorElement = field.parentElement.querySelector('.form-error');
    if (errorElement) {
      errorElement.remove();
    }
  }
};

// ==================== SCROLL EFFECTS ====================
const ScrollEffects = {
  init() {
    this.initHeaderScroll();
    this.initScrollAnimations();
    this.initSmoothScroll();
  },
  
  initHeaderScroll() {
    const header = document.querySelector('.navbar');
    if (!header) return;
    
    let lastScroll = 0;
    
    const handleScroll = Utils.throttle(() => {
      const currentScroll = window.pageYOffset;
      
      if (currentScroll > 100) {
        header.classList.add('scrolled');
      } else {
        header.classList.remove('scrolled');
      }
      
      lastScroll = currentScroll;
    }, 100);
    
    window.addEventListener('scroll', handleScroll);
  },
  
  initScrollAnimations() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('animate');
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '0px 0px -100px 0px'
    });
    
    document.querySelectorAll('[data-animate]').forEach(el => {
      observer.observe(el);
    });
  },
  
  initSmoothScroll() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
          Utils.scrollToElement(this.getAttribute('href'), 80);
        }
      });
    });
  }
};

// ==================== ANALYTICS ====================
const Analytics = {
  init() {
    this.trackPageView();
    this.initEventTracking();
  },
  
  trackPageView() {
    console.log('ðŸ“Š Page View:', window.location.pathname);
    // Integrate with your analytics service
  },
  
  trackEvent(category, action, label, value) {
    console.log('ðŸ“Š Event:', { category, action, label, value });
    
    // Google Analytics integration
    if (typeof gtag !== 'undefined') {
      gtag('event', action, {
        event_category: category,
        event_label: label,
        value: value
      });
    }
  },
  
  initEventTracking() {
    // Track button clicks
    document.querySelectorAll('[data-track]').forEach(element => {
      element.addEventListener('click', () => {
        const trackData = element.dataset.track.split('|');
        this.trackEvent(trackData[0], trackData[1], trackData[2]);
      });
    });
  }
};

// ==================== API CLIENT ====================
const API = {
  async request(endpoint, options = {}) {
    const defaultOptions = {
      headers: {
        'Content-Type': 'application/json',
      }
    };
    
    try {
      const response = await fetch(`${CONFIG.apiEndpoint}${endpoint}`, {
        ...defaultOptions,
        ...options
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('API Error:', error);
      throw error;
    }
  },
  
  get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  },
  
  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  },
  
  put(endpoint, data) {
    return this.request(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data)
    });
  },
  
  delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }
};

// ==================== EMAIL SERVICE ====================
const EmailService = {
  async init() {
    if (typeof emailjs !== 'undefined') {
      emailjs.init(CONFIG.emailJSUserID);
    }
  },
  
  async send(templateParams, templateId) {
    try {
      if (typeof emailjs === 'undefined') {
        throw new Error('EmailJS not loaded');
      }
      
      const response = await emailjs.send(
        CONFIG.emailJSServiceID,
        templateId,
        templateParams
      );
      
      return { success: true, response };
    } catch (error) {
      console.error('Email Error:', error);
      return { success: false, error };
    }
  }
};

// ==================== INITIALIZATION ====================
class SESMineApp {
  constructor() {
    this.initialized = false;
  }
  
  async init() {
    if (this.initialized) return;
    
    console.log('ðŸ”ï¸ Initializing SESMine Platform v' + CONFIG.version);
    
    try {
      // Initialize core systems
      LoadingManager.init();
      LoadingManager.show();
      
      NotificationManager.init();
      ModalManager.init();
      ScrollEffects.init();
      Analytics.init();
      
      await EmailService.init();
      
      // Initialize page-specific features
      this.initPageFeatures();
      
      // Setup event listeners
      this.setupEventListeners();
      
      this.initialized = true;
      console.log('âœ… SESMine Platform Ready');
      
      AppState.emit('appInitialized');
      
    } catch (error) {
      console.error('âŒ Initialization Error:', error);
      NotificationManager.error('Failed to initialize platform');
    }
  },
  
  initPageFeatures() {
    // Initialize features based on current page
    const page = document.body.dataset.page;
    
    switch(page) {
      case 'home':
        this.initHomePage();
        break;
      case 'dashboard':
        this.initDashboard();
        break;
      case 'login':
        this.initLoginPage();
        break;
      // Add more page-specific initializations
    }
  },
  
  initHomePage() {
    console.log('ðŸ  Initializing Home Page');
    // Home page specific code
  },
  
  initDashboard() {
    console.log('ðŸ“Š Initializing Dashboard');
    // Dashboard specific code
  },
  
  initLoginPage() {
    console.log('ðŸ” Initializing Login Page');
    // Login page specific code
  },
  
  setupEventListeners() {
    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + K: Quick search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        // Open search modal
      }
      
      // Escape: Close modals
      if (e.key === 'Escape') {
        ModalManager.closeAll();
      }
    });
    
    // Handle form submissions
    document.querySelectorAll('form[data-ajax]').forEach(form => {
      form.addEventListener('submit', this.handleFormSubmit.bind(this));
    });
  },
  
  async handleFormSubmit(e) {
    e.preventDefault();
    const form = e.target;
    
    // Validate form
    const validation = FormValidator.validate(form);
    if (!validation.isValid) {
      NotificationManager.error('Please fix form errors');
      return;
    }
    
    // Submit form
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);
    
    try {
      LoadingManager.show();
      const response = await API.post(form.action, data);
      LoadingManager.hide();
      
      NotificationManager.success('Form submitted successfully!');
      form.reset();
      
    } catch (error) {
      LoadingManager.hide();
      NotificationManager.error('Form submission failed');
    }
  }
}

// ==================== GLOBAL FUNCTIONS ====================
window.SESMine = {
  app: new SESMineApp(),
  utils: Utils,
  state: AppState,
  notifications: NotificationManager,
  modals: ModalManager,
  api: API,
  analytics: Analytics,
  
  // Expose common functions
  showNotification: (msg, type) => NotificationManager.show(msg, type),
  openModal: (id) => ModalManager.open(id),
  closeModal: (id) => ModalManager.close(id),
  trackEvent: (cat, act, lbl, val) => Analytics.trackEvent(cat, act, lbl, val)
};

// ==================== AUTO INITIALIZATION ====================
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.SESMine.app.init();
  });
} else {
  window.SESMine.app.init();
}

// ==================== PERFORMANCE MONITORING ====================
window.addEventListener('load', () => {
  const loadTime = performance.now();
  console.log(`âš¡ Platform loaded in ${loadTime.toFixed(2)}ms`);
  
  // Track performance metrics
  if ('PerformanceObserver' in window) {
    const perfObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.log('ðŸ“Š Performance:', entry.name, entry.duration);
      }
    });
    
    perfObserver.observe({ entryTypes: ['measure', 'navigation'] });
  }
});

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = window.SESMine;
}
